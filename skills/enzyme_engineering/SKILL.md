---
name: enzyme_engineering
description: "Enzyme Active Site Engineering - Engineer enzyme: identify active site residues, predict pocket, analyze binding site, and predict mutations. Use this skill for enzymology tasks involving predict functional residue run fpocket get binding site by id pred mutant sequence. Combines 4 tools from 3 SCP server(s)."
---

# Enzyme Active Site Engineering

**Discipline**: Enzymology | **Tools Used**: 4 | **Servers**: 3

## Description

Engineer enzyme: identify active site residues, predict pocket, analyze binding site, and predict mutations.

## Tools Used

- **`predict_functional_residue`** from `server-1` (sse) - `https://scp.intern-ai.org.cn/api/v1/mcp/1/VenusFactory`
- **`run_fpocket`** from `server-3` (streamable-http) - `https://scp.intern-ai.org.cn/api/v1/mcp/3/DrugSDA-Model`
- **`get_binding_site_by_id`** from `chembl-server` (streamable-http) - `https://scp.intern-ai.org.cn/api/v1/mcp/4/Origene-ChEMBL`
- **`pred_mutant_sequence`** from `server-3` (streamable-http) - `https://scp.intern-ai.org.cn/api/v1/mcp/3/DrugSDA-Model`

## Workflow

1. Identify active site residues
2. Predict catalytic pocket
3. Get binding site info from ChEMBL
4. Predict improved mutant sequences

## Test Case

### Input
```json
{
    "sequence": "MKTIIALSYIFCLVFA"
}
```

### Expected Steps
1. Identify active site residues
2. Predict catalytic pocket
3. Get binding site info from ChEMBL
4. Predict improved mutant sequences

## Usage Example

> **Note:** Replace `<YOUR_SCP_HUB_API_KEY>` with your own SCP Hub API Key. You can obtain one from the [SCP Platform](https://scp.intern-ai.org.cn).

```python
import asyncio
import json
from mcp import ClientSession
from mcp.client.streamable_http import streamablehttp_client
from mcp.client.sse import sse_client

SERVERS = {
    "server-1": "https://scp.intern-ai.org.cn/api/v1/mcp/1/VenusFactory",
    "server-3": "https://scp.intern-ai.org.cn/api/v1/mcp/3/DrugSDA-Model",
    "chembl-server": "https://scp.intern-ai.org.cn/api/v1/mcp/4/Origene-ChEMBL"
}

async def connect(url, transport_type):
    transport = streamablehttp_client(url=url, headers={"SCP-HUB-API-KEY": "<YOUR_SCP_HUB_API_KEY>"})
    read, write, _ = await transport.__aenter__()
    ctx = ClientSession(read, write)
    session = await ctx.__aenter__()
    await session.initialize()
    return session, ctx, transport

def parse(result):
    try:
        if hasattr(result, 'content') and result.content:
            c = result.content[0]
            if hasattr(c, 'text'):
                try: return json.loads(c.text)
                except: return c.text
        return str(result)
    except: return str(result)

async def main():
    # Connect to required servers
    sessions = {}
    sessions["server-1"], _, _ = await connect("https://scp.intern-ai.org.cn/api/v1/mcp/1/VenusFactory", "sse")
    sessions["server-3"], _, _ = await connect("https://scp.intern-ai.org.cn/api/v1/mcp/3/DrugSDA-Model", "streamable-http")
    sessions["chembl-server"], _, _ = await connect("https://scp.intern-ai.org.cn/api/v1/mcp/4/Origene-ChEMBL", "streamable-http")

    # Execute workflow steps
    # Step 1: Identify active site residues
    result_1 = await sessions["server-1"].call_tool("predict_functional_residue", arguments={})
    data_1 = parse(result_1)
    print(f"Step 1 result: {json.dumps(data_1, indent=2, ensure_ascii=False)[:500]}")

    # Step 2: Predict catalytic pocket
    result_2 = await sessions["server-3"].call_tool("run_fpocket", arguments={})
    data_2 = parse(result_2)
    print(f"Step 2 result: {json.dumps(data_2, indent=2, ensure_ascii=False)[:500]}")

    # Step 3: Get binding site info from ChEMBL
    result_3 = await sessions["chembl-server"].call_tool("get_binding_site_by_id", arguments={})
    data_3 = parse(result_3)
    print(f"Step 3 result: {json.dumps(data_3, indent=2, ensure_ascii=False)[:500]}")

    # Step 4: Predict improved mutant sequences
    result_4 = await sessions["server-3"].call_tool("pred_mutant_sequence", arguments={})
    data_4 = parse(result_4)
    print(f"Step 4 result: {json.dumps(data_4, indent=2, ensure_ascii=False)[:500]}")

    # Cleanup
    print("Workflow complete!")

if __name__ == "__main__":
    asyncio.run(main())
```
